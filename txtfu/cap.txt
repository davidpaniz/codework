
capistrano
    server          client
    ------          ------
    run             system
    sudo            `command`
    put             %x(command)
    stream          # ruby code
    download
    upload
    
cap 2.0
-------
Custom recipes
    
    app_checkout/vendor/plugins/*/recipes/*
                        plugins/webco/recipes/
                            common.rb
                            bbs.rb
                            brasigo.rb
                        
cap-2.0 recipes
    capistrano-2.1.0/
        bin/
        lib/
            capistrano.rb
            capistrano/
                cli.rb
                command.rb
                configuration.rb
                errors.rb
                extensions.rb
                gateway.rb
                logger.rb
                server_definition.rb
                shell.rb
                ssh.rb
                task_definition.rb
                upload.rb
                version.rb
                recipes/
                    deploy/
                    standard/
                    compat.rb
                    deploy.rb
                    standard.rb
                    upgrade.rb
                    
cap-2.0 deploy.rb

    /usr/lib/ruby/gems/1.8/gems/capistrano-2.5.x/
    /Library/Ruby/Gems/1.8/gems/capistrano-2.5.x/

namespace :deploy do
  desc <<-DESC
    Deploys your project. This calls both 'update' and 'restart'.
    this will generally only work for applications that have
  DESC
  task :default do
    update
    restart
  end

end

:group_writable
:keep_releases, 5
:app_user
:runner
:use_sudo, true

      depend :remote, :gem, "tzinfo", ">=0.3.3"
      depend :local, :command, "svn"
      depend :remote, :directory, "/u/depot/files"

    _cset(:release_name)      { set :deploy_timestamped, true; Time.now.utc.strftime("%Y%m%d%H%M%S") }

deploy
    update
        update_code
            strategy.deploy!
            finalize_update
        symlink
    restart
        try_runner "#{current_path}/script/process/reaper"
        
    -setup
    -upload
    -migrate
    -migrations
        update_code
        migrate
        symlink
        restart
    -check
    cold
        update
        migrate
        start

    start
        run "cd #{current_path} && #{try_runner} nohup script/spin"
    stop
        run "if [ -f #{current_path}/tmp/pids/dispatch.spawner.pid ]; then #{try_runner} #{current_path}/script/process/reaper -a kill -r dispatch.spawner.pid; fi"
        try_runner "#{current_path}/script/process/reaper -a kill"
    restart
        try_runner "#{current_path}/script/process/reaper"

    rollback
        default
            revision
            restart
            cleanup
        code
            revision
            cleanup
            
    pending
    pending:diff
    
    web:disable
    web:enable
    
   
# generating a dynamic file via deploy
desc "Generate spin script from variables"
task :generate_spin_script, :roles => :app do
    template = File.read(File.dirname(__FILE__) + "/templates/spin.erb"
    result   = ERB.new(template).result(binding)
    put result, "#{releae_path}/script/spin", :mode => 0755
end
after "deploy:update_code", "peepcode:generate_spin_script"

spin.erb
--------
#!/bin/bash

# AUTOGENERATED UPON DEPLOYMENT
# Do not edit this file.

<%= deploy_to %>/current/script/process/spawner \
    -p <%= mongrel_port %> \
    -i <%= mongrel_servers %> \
    -e <%= rails_env %>
                                                

duck punching
-------------

    ##
    # Print an informative message with asterisks.
    
    def inform(message)
      system echo '#{'*' * (message.length + 4)}'"
      system echo '#{message}'"     
      system echo '#{'*' * (message.length + 4)}'"
    end
    
    ##
    # Read a file and evaluete it as an ERB template.
    # Path is relative to this files's directory.
    
    def render_erb_template(filename)
      template = File.read(filename)
      result   = ERB.new(template).result(binding)
    end
    
    ##
    # Run a command and return the result as a string
    #
    
    def run_and_return(cmd)
      output = []
      run cmd do |ch, st, data|
        output << data
      end
      return output.to_s
    end
   
   
daemon_blogcamp.rb

